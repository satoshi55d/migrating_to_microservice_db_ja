## DevOps

DevOpsに関する定義は様々です。定義の多くは、文化、プロセス、そしてツールに関することがほとんどです。
間違ってはいないのですが、それらの事柄は全てDevOpsという、より大きな変革の一部に過ぎないのです。

DevOpsの目的は、ソフトウェア開発チームが自分の仕事の所有権を取り戻すことです。
私たち皆知っているように、仕事の結果から人を分断すると、良くない事態が発生します。
チーム全体、つまり開発チームと運用チームの両方がアプリケーションの成果物に対して責任を負わなければなりません。

本番環境に入る前に数ヶ月間リポジトリ内でコードが停滞することほど、開発者にとって大きな不満はありません。
我々は、何かしらの職務を遂行したり、人々の活動の中で生み出される差分を観察したりすることで、目に鮮やかなきらめきを取り戻す必要があります。

ソフトウェアを迅速かつ安全に提供する必要がありますが、私たちがそれを妨げるために頼りがちな言い訳は何でしょうか。
小規模から大規模、そして金融機関から電子商取引会社等、何百もの様々な開発チームの訪問を経て、一番の言い訳はバグであると確信しています。

どのソフトウェアリリースも、本番環境で数多くのバグを発生させてしまうために、ソフトウェアを迅速に提供しようとしないのです。

次の質問は、本番環境でバグが発生する原因は何なのかということです。これは、回答しやすいと思います。
本番環境での各リリースでは、コードや環境の変更がバグの原因です。
何か物事を変更する時は、何かしら壊れてしまうものです。
しかしながら、これを変更を加えない言い訳に使うことはできません！
変化は私たちの生活の一部です。結局のところ、変化は必然的な事象なのです。

変更とバグの間に簡単な相関関係を定義しましょう。
各リリースでの変更が多くなるほど、本番環境で発生するバグは増えます。
この定義は何の意味もないと思うでしょうか？
コードベース内でより沢山のコードが混ざり合うほど、どこかで何かがめちゃくちゃになる可能性が高くなります。

この問題を解決に導く伝統的な方法は、テストにより多くの時間をかけることです。
週単位でコードを書くのであれば、より多くのテストを行うために2週間は必要です。
月単位でコードを書くのであれば、2ヶ月は必要です。
遅かれ早かれ、どこかのチームが何かの記念日にしか本番環境へデプロイしようとしない光景が想像できます。

このアプローチは非経済的です。
本番環境におけるバグを減らす経済的なソフトウェアリリースアプローチは逆です。より頻繁にソフトウェアをリリースする必要があります。
そして、より頻繁にリリースすればするほど、リリース間の差分の量も削減していきます。
リリース間で変更が少ないほど、新しいバージョンが本番環境でバグを発生させる可能性は低くなります。

そして、たとえまだ本番環境にバグが残っているとしても、数十行のコードしか変更しなかった場合のバグの原因はどこにあるでしょうか？
変更が小さければ小さいほど、バグの原因を突き止めるのが簡単になり、修正するのも簡単になります。

DevOpsで使用される専門用語で、ソフトウェアの各リリース間の差分の大きさの特性を示すものとして、「バッチサイズ」というものがあります。
DevOpsが成功する原則新たに作るとしたら、次のような原則になるでしょう。

バッチサイズを対処可能な最小限のサイズにまで小さくしなさい。

そのためには、完全に自動化されたソフトウェアデプロイメントパイプラインが必要です。
そのパイプラインでは、全体の処理の流れの中でプロセスとツールが組み合わせられます。
しかしながら、バッチサイズを減らすためにあらゆるすべてのことを尽くしているところかも知れません。

#### 環境差異によるバグが一番ひどい

トラブルシューティングしている時、よくログやスタックトレースを見たり、デバッガーを使ったりします。
しかし、それでも、「でも、自分の端末では問題なく動いているんだ！」と言い張ってしまうのです。

自分の端末では動いたけれども、本番環境では動かないという恐ろしいシナリオは、環境差異によって起こります。
異なるOS、異なるカーネルバージョン、異なる依存バージョン、異なるデータベースドライバなどです。
実際のところ、今まで本番環境で問題なく動いていたことは驚くべきことです。

本番環境の構成にできる限り近い開発環境でアプリケーション開発、テスト、実行をする必要があります。
おそらく、開発環境でOracle RACや複数台のXeonサーバを持つことはできないでしょう。
しかし、開発機の仮想マシン（VM）上で本番環境と同じOracleバージョン、同じカーネルバージョン、同じアプリケーションサーババージョンを実行することはおそらく可能です。

[Ansible](https://www.ansible.com/)、[Puppet](https://puppet.com/ja)、[Chef](https://www.chef.io/)などの
Infrastructure-as-codeツールたちが輝きを放ち、複数環境のインフラストラクチャの設定を自動化します。
それらを使用することを強く推奨します。そして、それらのスクリプトはアプリケーションコードと同じソースリポジトリにコミットすべきです。[^2]
通常、環境設定とアプリケーションコードは一致しています。一緒にバージョン管理できない理由があるのでしょうか。

[コンテナ技術](https://www.redhat.com/ja/containers)は多くのメリットを提供しますが、
アプリケーションと環境を1つの格納装置（コンテナ）にパッケージングすることによって、環境差異による問題を解決する場合に特に役に立ちます。
具体的には、アプリケーションと環境を単一の単位でパッケージ化した成果物を仮想アプライアンスと呼びます。
仮想アプライアンスはVMを介してセットアップできますが、起動するには容量が大きすぎるだけでなく時間がかかる傾向があります。
コンテナは、仮想アプライアンスのサイズと起動時間を最小限に抑え、コンテナイメージを簡単に配布したり、利用したりすることで、仮想アプライアンスをさらに一歩進化させます。

別の人気ツールとして[Vagrant](https://www.vagrantup.com/)があります。
現在、Vagrantはそれ以上の機能を提供していますが、元々は本番環境と似通った開発環境を簡単にセットアップできるプロビジョニングツールとして開発されました。
文字通りVagrantfileといくつか設定スクリプトを用意し、vagrant upコマンドを実行するだけで開発の依存関係を解決し、実行可能なフル機能のVMまたはコンテナを作成できます。


[^2]:ツールのベストプラクティスに従い、パスワードなどの機密情報を、権限のないユーザーがアクセスできる場所に保存しないでください。